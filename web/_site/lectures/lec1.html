<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Haskell @ Club De Science - lec1</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
      <h1>Haskell @ Club De Science  - lec1 </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
		<a href="../lectures.html">Lectures</a>
	    <a href="../links.html">Links</a>
        </div>
	<br />
	<br />
	<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Intro</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (length, head, tail, (++))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Char</span> (toLower)</code></pre></div>
<h2 id="hello-world-the-factorial-function">Hello World: The factorial Function</h2>
<p>Factorials are very simple things. They’re just products, indicated by an exclamation mark. For instance, “four factorial” is written as “4!” and means 1×2×3×4 = 24. In general, n! (“enn factorial”) means the product of all the whole numbers from 1 to n; that is, n! = 1×2×3×…×n.</p>
<ul>
<li><p>Examples</p>
<pre><code>1! = 1
2! = 1 * 2 = 2
3! = 1 * 2 * 3 = 6</code></pre></li>
<li><p>Product Definition</p></li>
</ul>
<pre><code>    n! =  1 * 2 * ... * n</code></pre>
<ul>
<li>Recursive Definition</li>
</ul>
<pre><code>    n! = 1          , if n == 0
    n! = n * (n-1)! , if n &gt;  0 </code></pre>
<ul>
<li>Haskell implementation</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fact ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> fact n <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="fu">*</span> fact (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>Alternative Syntax</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fact' <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="ot">&gt;</span> fact' n <span class="fu">=</span> n <span class="fu">*</span> fact'(n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
Yet, another Haskell syntax
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fact'' n 
<span class="ot">&gt;</span>   <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise <span class="fu">=</span> n <span class="fu">*</span> fact'' (n<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<h2 id="exercise-1">Exercise 1</h2>
<p>In mathematics, the Fibonacci numbers or Fibonacci sequence are the numbers in the following integer sequence:</p>
<pre><code>  1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...</code></pre>
<p>By definition, the first two numbers in the Fibonacci sequence are 1 and 1, and each subsequent number is the sum of the previous two. In mathematical terms, the sequence Fn of Fibonacci numbers is defined by the recurrence relation</p>
<pre><code>    F 1 = 1
    F 2 = 1
    F n = F (n-1) + F (n-2)</code></pre>
<p>Write the fibonacci function!</p>
<h2 id="exercise-2">Exercise 2</h2>
<p>The Towers of Hanoi is a puzzle where you are given three pegs, on one of which are stacked <code>n</code> discs in increasing order of size. To solve the puzzle, you must move all the discs from the starting peg to another by moving only one disc at a time and never stacking a larger disc on top of a smaller one. To move <code>n</code> discs from peg a to peg b using peg c as temporary storage:</p>
<ul>
<li>Move n - 1 discs from peg a to peg c.</li>
<li>Move the remaining disc from peg a to peg b.</li>
<li>Move n - 1 discs from peg c to peg b.</li>
</ul>
<p>Write a function</p>
<pre><code>hanoi :: Int -&gt; String -&gt; String -&gt; String -&gt; IO ()
hanoi = error &quot;Define me!&quot;</code></pre>
<p>that, given the number of discs n and peg names a, b, and c, where a is the starting peg, emits the series of moves required to solve the puzzle. For example, running hanoi 2 “a” “b” “c”</p>
<p>should emit the text</p>
<pre><code>[(&quot;a&quot;,&quot;c&quot;),(&quot;a&quot;,&quot;b&quot;),(&quot;c&quot;,&quot;b&quot;)]</code></pre>
<h2 id="basic-type-information">Basic Type Information</h2>
<p>What is the type of fac?</p>
<pre><code>fact :: Int     -&gt; Int   
fact :: Double  -&gt; Double
fact :: Real    -&gt; Real
....</code></pre>
<p>The type of <code>fact</code> can be <code>a -&gt; a</code> for <em>any</em> type <code>a</code> that supports</p>
<ul>
<li>equality <code>(==)</code></li>
<li>minus <code>(-)</code></li>
<li>multiplication <code>(*)</code></li>
</ul>
<p>Equality is implemented with an interface (<code>class</code> in Haskell terms) we call <code>Eq</code> and numeric operations by <code>Num</code>. Thus, the type of <code>fact</code> is from- and to any type (variable) <code>a</code> that <em>instantiates</em> <code>Num</code> and <code>Eq</code>.</p>
<pre><code>fact :: (Num a, Eq a) =&gt; a -&gt; a</code></pre>
<h2 id="data-types">Data Types</h2>
<p>What should happen if I call <code>fact</code> with a negative number? <em>Throw an error!!!</em></p>
<p>If the argument is negative (n &lt; 0) factorial is not defined. Build a data structure (<code>ErrInt</code>) that tags the result of factorial as</p>
<ul>
<li>Error n (for negative <code>n</code>s)</li>
<li>Value n (for the real result)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Err</span> a <span class="fu">=</span> <span class="dt">Error</span> a <span class="fu">|</span> <span class="dt">Value</span> a</code></pre></div>
<p>Note: When you want to use the result of the factorial you need to case analyse to distinguish if it is an Error or a Value:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; factErr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Err</span> <span class="dt">Int</span> 
<span class="ot">&gt;</span> factErr n 
<span class="ot">&gt;</span>   <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dt">Value</span> <span class="dv">1</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> n <span class="fu">&gt;</span>  <span class="dv">0</span>    <span class="fu">=</span> <span class="kw">case</span> factErr (n<span class="fu">-</span><span class="dv">1</span>) <span class="kw">of</span> 
<span class="ot">&gt;</span>   	            <span class="dt">Value</span> m <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="fu">$</span> n <span class="fu">*</span> m
<span class="ot">&gt;</span>   	            <span class="dt">Error</span> m <span class="ot">-&gt;</span> <span class="dt">Error</span> m
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Error</span> n</code></pre></div>
<h2 id="what-is-that-dollar">What is that dollar? (<code>$</code>)</h2>
<p>It is a “silly” function commonly used in Haskell to avoid parenthesis. When you see <code>f $ e</code> you can replace it with parenthesyzing the right part of dollar: <code>f (e)</code> Dollar is defined as:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">infixr</span> <span class="dv">0</span> <span class="fu">$$</span> 
<span class="ot">&gt;</span> f <span class="fu">$$</span> x <span class="fu">=</span> f x</code></pre></div>
<h2 id="lists">Lists</h2>
<p>We saw <code>Err a</code> as a data type that wraps values of type <code>a</code>. The most used Haskell data type is a list</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]<span class="ot">            ::</span> [<span class="dt">Int</span>]
[<span class="dt">True</span>]<span class="ot">               ::</span> [<span class="dt">Bool</span>]
[<span class="ch">'c'</span>, <span class="ch">'h'</span>, <span class="ch">'a'</span>, <span class="ch">'r'</span>]<span class="ot"> ::</span> [<span class="dt">Char</span>] 
<span class="st">&quot;char&quot;</span><span class="ot">               ::</span> <span class="dt">String</span></code></pre></div>
<h2 id="exercise">Exercise</h2>
<p>What is the type of the empty list</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[]<span class="ot"> ::</span> <span class="fu">??</span></code></pre></div>
<p>List operations</p>
<ul>
<li>Getting the length of a list</li>
</ul>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; length ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> length []     <span class="fu">=</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> length (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> length xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">length [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>] <span class="fu">=</span> <span class="dv">4</span>
length []           <span class="fu">=</span> <span class="dv">0</span>
length <span class="st">&quot;string&quot;</span>     <span class="fu">=</span> <span class="dv">6</span></code></pre></div>
<p>Note: <code>length</code> is <em>polymorphic</em> it operates on lists of every type.</p>
<ul>
<li>Getting the head of a list
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; head ::</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> head (x<span class="fu">:</span>_) <span class="fu">=</span> x
<span class="ot">&gt;</span> head []    <span class="fu">=</span> error <span class="st">&quot;head on empty list&quot;</span></code></pre></div></li>
</ul>
<h2 id="exercise-3">Exercise</h2>
<p>Get the tail of a list</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tail <span class="st">&quot;Mexico!!!!!&quot;</span> <span class="fu">=</span> <span class="st">&quot;exico!!!!!&quot;</span>
tail [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]  <span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tail ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> tail <span class="fu">=</span> undefined</code></pre></div>
<h2 id="exercise-4">Exercise</h2>
<p>Concatinate two lists</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;I love &quot;</span> <span class="fu">++</span> <span class="st">&quot;Mexico!!!!!&quot;</span> <span class="fu">=</span> <span class="st">&quot;I love Mexico!!!!!&quot;</span>
[<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>]   <span class="fu">++</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]  <span class="fu">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> [] <span class="fu">++</span> xs <span class="fu">=</span> xs</code></pre></div>
<h2 id="computation-patters-mapping">Computation Patters: mapping</h2>
<p>Lets write a function that converts a string to uppercase. Recall that in Haskell, a String is just a list of Char. We must start with a function that will convert an individual Char to its uppercase version. Once we find this function, we will simply jog over the list, and apply the function to each Char.</p>
<p>How might we find such a transformer? Lets query Hoogle for a function of the appropriate type! Ah, we see that the module Data.Char contains a function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">toLower<span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></code></pre></div>
<p>and so now, we can write the simple recursive function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toLowerString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
toLowerString []     <span class="fu">=</span> []
toLowerString (c<span class="fu">:</span>cs) <span class="fu">=</span> toLower c <span class="fu">:</span> toLowerString cs</code></pre></div>
<p>Lets now write a function that given a list of integers increases each of its elements by 1</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plusOneList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
plusOneList []     <span class="fu">=</span> []
plusOneList (n<span class="fu">:</span>ns) <span class="fu">=</span> (n<span class="fu">+</span><span class="dv">1</span>) <span class="fu">:</span> plusOneList ns</code></pre></div>
<p>Now, in a lesser language, you might be quite happy with the above code. But what separates a good programmer from a great one, is the ability to abstract.</p>
<p>Like humans and monkeys, the functions <code>toLowerString</code> and <code>plusOneList</code> share 93% of their DNA — the notion of jogging over the list. The common pattern is described by the polymorphic higher-order function map</p>
<pre><code>map f []     = []
map f (x:xs) = (f x) : (map f xs)</code></pre>
<p>How did we arrive at this? Well, you find what is enshrine in the function’s body that which is common to the different instances, namely the recursive jogging strategy; and the bits that are different, simply become the function’s parameters! Thus, the map function abstracts, or if you have a vivid imagination, locks up in a bottle, the extremely common pattern of jogging over the list.</p>
<p>Verily, the type of map tells us exactly what it does</p>
<pre><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<p>That is, it takes an <code>a -&gt; b</code> transformer and list of a values, and transforms each value to return a list of b values. We can now safely reuse the pattern, by instantiating the transformer with different specific operations.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> toLowerString <span class="fu">=</span> map toLower
<span class="ot">&gt;</span> plusOneList   <span class="fu">=</span> map (<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<p>Much better.</p>
<h2 id="mapping-err-values">Mapping <code>Err</code> values</h2>
<p>Write a function that increases the value of the <code>Err</code> data by one.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plusOneErr ::</span> <span class="dt">Err</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Err</span> <span class="dt">Int</span>
plusOneErr <span class="fu">=</span> undefined</code></pre></div>
<p>Did you follow the mapping abstraction discussed above? If so, you would define a mapping function for <code>Err</code> values</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mapErr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Err</span> a <span class="ot">-&gt;</span> <span class="dt">Err</span> b
<span class="ot">&gt;</span> mapErr f (<span class="dt">Error</span> x) <span class="fu">=</span> <span class="dt">Error</span> <span class="fu">$</span> f x 
<span class="ot">&gt;</span> mapErr f (<span class="dt">Value</span> x) <span class="fu">=</span> <span class="dt">Value</span> <span class="fu">$</span> f x </code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; plusOneErr ::</span> <span class="dt">Err</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Err</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> plusOneErr <span class="fu">=</span> mapErr (<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<p>Then, use <code>mapErr</code> to write the desired function.</p>
<p>We take the abstraction one level up! See how <code>map</code> and <code>mapErr</code> are similar</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">map<span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="ot">mapErr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Err</span> a <span class="ot">-&gt;</span> <span class="dt">Err</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">	fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></div>
<h2 id="answers-to-the-exercises">Answers to the Exercises</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span> 
<span class="ot">&gt;</span> fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="ot">&gt;</span> fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; hanoi ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
<span class="ot">&gt;</span> hanoi <span class="dv">0</span> _ _ _ <span class="fu">=</span> []
<span class="ot">&gt;</span> hanoi n a b c <span class="fu">=</span> hanoi (n<span class="fu">-</span><span class="dv">1</span>) a c b <span class="fu">++</span> [(a,b)] <span class="fu">++</span> hanoi (n<span class="fu">-</span><span class="dv">1</span>) c b a</code></pre></div>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
